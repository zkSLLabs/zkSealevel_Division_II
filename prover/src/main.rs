#![forbid(unsafe_code)]
#![deny(warnings, clippy::all, clippy::pedantic, clippy::nursery, clippy::cargo)]
#![deny(clippy::unwrap_used, clippy::expect_used, clippy::panic, clippy::todo, clippy::unimplemented)]
#![deny(clippy::indexing_slicing, clippy::arithmetic_side_effects, clippy::float_arithmetic, clippy::as_conversions)]
#![deny(clippy::else_if_without_else, clippy::shadow_reuse, clippy::wildcard_enum_match_arm)]
#![deny(missing_docs, rustdoc::broken_intra_doc_links)]
#![deny(clippy::missing_docs_in_private_items)]
//! zksl-prover: canonical artifact hashing and DS signing

use blake3::Hasher as Blake3;
use clap::Parser;
#[cfg(feature = "stark")]
use clap::Subcommand;
use ed25519_dalek::{Signer, Keypair};
use serde::{Deserialize, Serialize};
use std::{fs, path::PathBuf};

#[derive(Parser, Debug)]
#[command(name = "prover", version, about = "zkSealevel prover & STARK toolkit")]
struct Args {
    #[cfg(feature = "stark")]
    #[command(subcommand)]
    cmd: Option<Cmd>,
    // Backward-compatible flags (sign-ds mode) used by scripts/conformance.js
    #[arg(long)]
    input: Option<String>,
    #[arg(long)]
    out: Option<String>,
    #[arg(long, default_value = "./keys/aggregator.json")]
    agg_key: String,
    #[arg(long, default_value_t = 1u64)]
    chain_id: u64,
    #[arg(long, default_value = "@@ENV_OR_FALLBACK@@")]
    program_id: String,
    #[arg(long, default_value_t = 1u64)]
    seq: u64,
}

#[cfg(feature = "stark")]
#[derive(Subcommand, Debug, Clone)]
enum Cmd {
    /// Generate a STARK proof for Solana validator state transitions
    StarkProve {
        #[arg(long)] start: u64,
        #[arg(long)] end: u64,
        #[arg(long, value_name="HEX32")] before: Option<String>,
        #[arg(long, value_name="HEX32")] after: Option<String>,
        #[arg(long, value_name="HEX32")] proof_hash: Option<String>,
        #[arg(long)] out: String,
    },
    /// Verify a STARK proof generated by StarkProve
    StarkVerify {
        #[arg(long)] proof: String,
    },
    /// Generate witness from Solana RPC for given slot range
    GenerateWitness {
        #[arg(long)] rpc: String,
        #[arg(long)] start: u64,
        #[arg(long)] end: u64,
        #[arg(long)] out: String,
    },
    /// Generate STARK proof from REAL RPC data (fetches witness automatically)
    StarkProveReal {
        #[arg(long)] rpc: String,
        #[arg(long)] start: u64,
        #[arg(long)] end: u64,
        #[arg(long, value_name="HEX32")] proof_hash: String,
        #[arg(long)] out: String,
    },
}

#[derive(Serialize, Deserialize)]
struct Artifact {
    artifact_id: String,
    start_slot: u64,
    end_slot: u64,
    state_root_before: String,
    state_root_after: String,
}

#[cfg(feature = "stark")]
mod stark;

// North Star Option A AIR (enabled when REQUIRE_STARK=1 at runtime)
#[allow(dead_code)]
mod north_star;
#[cfg(feature = "stark")]
mod witness;
#[cfg(feature = "stark")]
mod merkle;

fn main() -> anyhow::Result<()> {
    // Allow env override for program_id if default placeholder is present
    let mut args = Args::parse();
    if args.program_id == "@@ENV_OR_FALLBACK@@" {
        if let Ok(pid) = std::env::var("PROGRAM_ID_VALIDATOR_LOCK") {
            args.program_id = pid;
        } else {
            // Safe base58 placeholder that forces caller to pass --program-id explicitly
            args.program_id = "11111111111111111111111111111111".to_string(); // System Program
        }
    }

    #[cfg(feature = "stark")]
    if let Some(cmd) = args.cmd.clone() {
        match cmd {
            Cmd::StarkProve { start, end, before: _before, after: _after, proof_hash, out } => {
                // Prefer North Star Route: fetch witness from RPC and generate proof bound to PI set
                let rpc = std::env::var("RPC_URL").unwrap_or_else(|_| "https://api.devnet.solana.com".to_string());
                let proof_hash_hex = proof_hash.unwrap_or_else(|| "0".repeat(64));
                let proof_hash_arr = stark::hex32_to_array(&proof_hash_hex)?;
                let proof = stark::generate_stark_proof_from_witness(&rpc, start, end, proof_hash_arr)?;
                let pi = &proof.public_inputs;
                let json = serde_json::json!({
                    "public_inputs": {
                        "start": pi.start,
                        "end": pi.end,
                        "before": hex::encode(pi.before),
                        "after": hex::encode(pi.after),
                        "proof_hash": hex::encode(pi.proof_hash),
                        "c_in_hex": pi.c_in_hex,
                        "c_out_hex": pi.c_out_hex,
                        "h_b_hex": pi.h_b_hex,
                        "s_in": pi.s_in,
                        "s_out": pi.s_out
                    },
                    "proof_b64": proof.proof_b64
                });
                std::fs::write(out, serde_json::to_vec_pretty(&json)?)?;
                return Ok(());
            }
            Cmd::StarkVerify { proof } => {
                let raw = std::fs::read_to_string(proof)?;
                let v: serde_json::Value = serde_json::from_str(&raw)?;
                let proof_b64 = v.get("proof_b64").and_then(|x| x.as_str()).ok_or_else(|| anyhow::anyhow!("missing proof_b64"))?;
                let start = v.get("public_inputs").and_then(|o| o.get("start")).and_then(|x| x.as_u64()).unwrap_or(1);
                let end = v.get("public_inputs").and_then(|o| o.get("end")).and_then(|x| x.as_u64()).unwrap_or(1);
                let before_hex = v.get("public_inputs").and_then(|o| o.get("before")).and_then(|x| x.as_str()).unwrap_or("0");
                let after_hex = v.get("public_inputs").and_then(|o| o.get("after")).and_then(|x| x.as_str()).unwrap_or("0");
                let ph_hex = v.get("public_inputs").and_then(|o| o.get("proof_hash")).and_then(|x| x.as_str()).unwrap_or("0");
                let before_arr = stark::hex32_to_array(before_hex)?;
                let after_arr = stark::hex32_to_array(after_hex)?;
                let ph_arr = stark::hex32_to_array(ph_hex)?;
				let p = stark::StarkOutput {
					public_inputs: stark::PublicInputs {
						start,
						end,
						before: before_arr,
						after: after_arr,
						proof_hash: ph_arr,
						c_in_hex: String::new(),
						c_out_hex: String::new(),
						h_b_hex: String::new(),
						s_in: Vec::new(),
						s_out: Vec::new(),
					},
					proof_b64: proof_b64.to_string(),
				};
                stark::verify_stark_proof(&p)?;
                println!("{{\"status\":\"ok\"}}");
                return Ok(());
            }
            Cmd::GenerateWitness { rpc, start, end, out } => {
                let witnesses = witness::generate_witness_from_rpc(&rpc, start, end)?;
                let (before, after) = witness::generate_state_roots(&rpc, start, end)?;
                let output = serde_json::json!({
                    "start_slot": start,
                    "end_slot": end,
                    "state_root_before": hex::encode(before),
                    "state_root_after": hex::encode(after),
                    "witnesses": witnesses,
                });
                std::fs::write(out, serde_json::to_vec_pretty(&output)?)?;
                println!("{{\"status\":\"ok\",\"before\":\"{}\",\"after\":\"{}\"}}",hex::encode(before),hex::encode(after));
                return Ok(());
            }
            Cmd::StarkProveReal { rpc, start, end, proof_hash, out } => {
                let proof_hash_arr = stark::hex32_to_array(&proof_hash)?;
                println!("Fetching REAL validator vote accounts from RPC: {}", rpc);
                let proof = stark::generate_stark_proof_from_witness(&rpc, start, end, proof_hash_arr)?;
                let json = serde_json::json!({
                    "public_inputs": {
                        "start": proof.public_inputs.start,
                        "end": proof.public_inputs.end,
                        "before": hex::encode(proof.public_inputs.before),
                        "after": hex::encode(proof.public_inputs.after),
                        "proof_hash": hex::encode(proof.public_inputs.proof_hash),
                        "c_in_hex": proof.public_inputs.c_in_hex,
                        "c_out_hex": proof.public_inputs.c_out_hex,
                        "h_b_hex": proof.public_inputs.h_b_hex,
                        "s_in": proof.public_inputs.s_in,
                        "s_out": proof.public_inputs.s_out
                    },
                    "proof_b64": proof.proof_b64
                });
                std::fs::write(out, serde_json::to_vec_pretty(&json)?)?;
                println!("{{\"status\":\"ok\",\"proof_generated_from_real_rpc\":true}}");
                return Ok(());
            }
        }
    }
    let input = args.input.as_ref().ok_or_else(|| anyhow::anyhow!("--input required"))?;
    let out = args.out.as_ref().ok_or_else(|| anyhow::anyhow!("--out required"))?;
    let data = fs::read_to_string(input)?;
    let artifact: Artifact = serde_json::from_str(&data)?;
    // Default mode: DS signing for conformance runner
    // proof_hash over canonical JSON (JCS-like) bytes
    let json = canonicalize(&artifact);
    let mut h = Blake3::new();
    h.update(json.as_bytes());
    let proof_hash = *h.finalize().as_bytes();
    // build DS from real inputs
    let chain_id: u64 = args.chain_id;
    let program_id = bs58::decode(args.program_id).into_vec()?;
    let program_id: [u8; 32] = program_id.try_into().map_err(|_| anyhow::anyhow!("invalid program_id"))?;
    let seq: u64 = args.seq;
    let mut ds = Vec::new();
    ds.extend_from_slice(b"zKSL/anchor/v1");
    ds.extend_from_slice(&chain_id.to_le_bytes());
    ds.extend_from_slice(&program_id);
    ds.extend_from_slice(&proof_hash);
    ds.extend_from_slice(&artifact.start_slot.to_le_bytes());
    ds.extend_from_slice(&artifact.end_slot.to_le_bytes());
    ds.extend_from_slice(&seq.to_le_bytes());
    let mut hd = Blake3::new();
    hd.update(&ds);
    let ds_hash = *hd.finalize().as_bytes();
    // sign DS using aggregator secret key from file (hex 64 bytes seed+key)
    let agg_bytes = read_aggregator_secret(&args.agg_key)?;
    let keypair_bytes: [u8; 64] = if agg_bytes.len() == 64 {
        agg_bytes[..].try_into().map_err(|_| anyhow::anyhow!("Failed to convert to [u8; 64]"))?
    } else {
        anyhow::bail!("Invalid aggregator key format, expected 64 bytes");
    };
    let keypair = Keypair::from_bytes(&keypair_bytes)?;
    let sig = keypair.sign(&ds);

    let output_json = serde_json::json!({
        "artifact_id": artifact.artifact_id,
        "proof_hash": hex::encode(proof_hash),
        "ds_hash": hex::encode(ds_hash),
        "signature": hex::encode(sig.to_bytes()),
    });
    fs::write(out, serde_json::to_vec_pretty(&output_json)?)?;
    Ok(())
}

fn canonicalize<T: Serialize>(value: &T) -> String {
    // Deterministic map key ordering
    // Serialize, parse, and re-serialize with sorted keys
    let v = serde_json::to_value(value).unwrap_or(serde_json::Value::Null);
    stringify_canonical(&v)
}

fn stringify_canonical(v: &serde_json::Value) -> String {
    match v {
        serde_json::Value::Null => "null".to_string(),
        serde_json::Value::Bool(b) => {
            if *b { "true".to_string() } else { "false".to_string() }
        }
        serde_json::Value::Number(n) => n.to_string(),
        serde_json::Value::String(s) => serde_json::to_string(s).unwrap_or_else(|_| String::from("\"\""))  ,
        serde_json::Value::Array(a) => {
            let inner: Vec<String> = a.iter().map(stringify_canonical).collect();
            format!("[{}]", inner.join(","))
        }
        serde_json::Value::Object(m) => {
            let mut keys: Vec<&String> = m.keys().collect();
            keys.sort();
            let inner: Vec<String> = keys.iter().filter_map(|k| {
                let key = serde_json::to_string(k).ok()?;
                let val = stringify_canonical(m.get(*k)?);
                Some(format!("{key}:{val}"))
            }).collect();
            format!("{{{}}}", inner.join(","))
        }
    }
}

fn read_aggregator_secret(path: &str) -> anyhow::Result<Vec<u8>> {
    let p = PathBuf::from(path);
    let raw = fs::read_to_string(p)?;
    let v: serde_json::Value = serde_json::from_str(&raw)?;
    let hex = v.get("secretKey").and_then(|x| x.as_str()).ok_or_else(|| anyhow::anyhow!("missing secretKey"))?;
    let bytes = hex::decode(hex)?;
    if bytes.len() != 64 { anyhow::bail!("secretKey must be 64 hex bytes"); }
    Ok(bytes)
}


